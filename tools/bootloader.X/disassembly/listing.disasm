Disassembly Listing for bootloader
Generated From:
/home/reder/projects/stell2019/tools/bootloader.X/dist/default/debug/bootloader.X.debug.elf
23.08.2019 15:15:31

---  /home/reder/projects/stell2019/tools/bootloader.X/source/boot.c  -----------------------------------
1:             /*
2:              * Copyright 2019 Wolfgang Reder.
3:              *
4:              * Licensed under the Apache License, Version 2.0 (the "License");
5:              * you may not use this file except in compliance with the License.
6:              * You may obtain a copy of the License at
7:              *
8:              *      http://www.apache.org/licenses/LICENSE-2.0
9:              *
10:             * Unless required by applicable law or agreed to in writing, software
11:             * distributed under the License is distributed on an "AS IS" BASIS,
12:             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:             * See the License for the specific language governing permissions and
14:             * limitations under the License.
15:             */
16:            #define F_CPU_RESET                 (20E6/6)
17:            
18:            #include <avr/io.h>
19:            #include <string.h>
20:            #include "types.h"
21:            #include "bootloader.h"
22:            #include "e2mem.h"
23:            /* Memory configuration
24:             * BOOTEND_FUSE * 256 must be above Bootloader Program Memory Usage,
25:             * this is 490 bytes at optimization level -O3, so BOOTEND_FUSE = 0x02
26:             */
27:            #define BOOTEND_FUSE                (0x01)
28:            #define BOOT_SIZE                   (BOOTEND_FUSE * 0x100)
29:            #define MAPPED_APPLICATION_START    (MAPPED_PROGMEM_START + BOOT_SIZE)
30:            #define MAPPED_APPLICATION_SIZE     (MAPPED_PROGMEM_SIZE - BOOT_SIZE)
31:            
32:            /* Fuse configuration
33:             * BOOTEND sets the size (end) of the boot section in blocks of 256 bytes.
34:             * APPEND = 0x00 defines the section from BOOTEND*256 to end of Flash as application code.
35:             * Remaining fuses have default configuration.
36:             */
37:            FUSES = {
38:            	.OSCCFG = FREQSEL_20MHZ_gc,
39:            	.SYSCFG0 = CRCSRC_NOCRC_gc | RSTPINCFG_UPDI_gc,
40:            	.SYSCFG1 = SUT_64MS_gc,
41:            	.APPEND = 0x00,
42:            	.BOOTEND = BOOTEND_FUSE
43:            };
44:            
45:            
46:            bool bootloaderRequired EEMEM = true;
47:            
48:            
49:            /* Define application pointer type */
50:            typedef void (*const app_t) (void);
51:            
52:            /* Interface function prototypes */
53:            static bool is_bootloader_requested(void);
54:            static void init_twi(void);
55:            static void updateflash();
56:            static bool page_load(update_rec*);
57:            static void page_write(update_rec*);
58:            
59:            /*
60:             * Main boot function
61:             * Put in the constructors section (.ctors) to save Flash.
62:             * Naked attribute used since function prologue and epilogue is unused
63:             */
64:            __attribute__((naked)) __attribute__((section(".ctors"))) void
65:            boot(void)
66:            {
67:            	/* Initialize system for AVR GCC support, expects r1 = 0 */
68:            	asm volatile("clr r1");
0000  2411     EOR R1, R1
69:            	// Init Stack !
70:            	SP = RAMEND;
0001  E38D     LDI R24, 0x3D
0002  E090     LDI R25, 0x00
0003  EF2F     LDI R18, 0xFF
0004  E33F     LDI R19, 0x3F
0005  01FC     MOVW R30, R24
0006  8320     ST Z, R18
0007  8331     STD Z+1, R19
71:            
72:            	//	if (!is_bootloader_requested()) {
73:            	//		app_t app = (app_t) (BOOT_SIZE / sizeof(app_t));
74:            	//		app();
75:            	//	} else {
76:            	init_twi();
0008  D020     RCALL 0x29
77:            	updateflash();
0009  D006     RCALL 0x10
78:            	//	}
79:            	//	/* Issue system reset */
80:            	_PROTECTED_WRITE(RSTCTRL.SWRR, RSTCTRL_SWRE_bm);
000A  ED88     LDI R24, 0xD8
000B  E091     LDI R25, 0x01
000C  BF84     OUT 0x34, R24
000D  9390     STS 0x00, R25
81:            }
000F  0000     NOP
82:            
83:            static void updateflash()
84:            {
0010  93CF     PUSH R28
0011  93DF     PUSH R29
0012  B7CD     IN R28, 0x3D
0013  B7DE     IN R29, 0x3E
0014  54C3     SUBI R28, 0x43
0015  09D1     SBC R29, R1
0016  BFCD     OUT 0x3D, R28
0017  BFDE     OUT 0x3E, R29
85:            	update_rec page_buffer;
86:            	memset(&page_buffer, 0, sizeof(page_buffer));
0018  E443     LDI R20, 0x43
0019  E050     LDI R21, 0x00
001A  E060     LDI R22, 0x00
001B  E070     LDI R23, 0x00
001C  01CE     MOVW R24, R28
001D  9601     ADIW R24, 0x01
001E  D048     RCALL 0x67
87:            	while (1) {
88:            		while (page_load(&page_buffer)) {
001F  C003     RJMP 0x23
0023  01CE     MOVW R24, R28
0024  9601     ADIW R24, 0x01
0025  D00B     RCALL 0x31
0026  2388     AND R24, R24
0027  F7C1     BRNE 0x20
89:            			page_write(&page_buffer);
0020  01CE     MOVW R24, R28
0021  9601     ADIW R24, 0x01
0022  D032     RCALL 0x55
90:            		}
91:            	}
0028  CFF6     RJMP 0x1F
92:            }
93:            
94:            /*
95:             * Boot access request function
96:             */
97:            static bool is_bootloader_requested(void)
98:            {
99:            	return true;
100:           	//if (*(&bootloaderRequired + MAPPED_EEPROM_START) == 0) {
101:           	//	if (e2mem_read_uint8(&bootloaderRequired) == 0) { // no forced update requested, check crc
102:           	//		CRCSCAN.CTRLB = 0; //Priority on Flash; Scan entire Flash
103:           	//
104:           	//		CRCSCAN.CTRLA = 1 << CRCSCAN_ENABLE_bp /* Enable CRC scan: enabled */
105:           	//			| 0 << CRCSCAN_NMIEN_bp;
106:           	//		return !(CRCSCAN_STATUS & CRCSCAN_OK_bm);
107:           	//	}
108:           	//	return true;
109:           }
110:           
111:           /*
112:            * Communication interface functions
113:            */
114:           static void
115:           init_twi(void)
116:           {
0029  93CF     PUSH R28
002A  93DF     PUSH R29
002B  B7CD     IN R28, 0x3D
002C  B7DE     IN R29, 0x3E
117:           	/* Switch pins to alternate TWI pin location */
118:           	//	PORTMUX.CTRLB |= PORTMUX_TWI0_ALTERNATE_gc;
119:           
120:           	/* Enable TWI driver */
121:           	//	i2c_slave_init();
122:           }
002D  0000     NOP
002E  91DF     POP R29
002F  91CF     POP R28
0030  9508     RET
123:           
124:           static bool
125:           page_load(update_rec* page_buffer)
126:           {
0031  93CF     PUSH R28
0032  93DF     PUSH R29
0033  D000     RCALL 0x34
0034  B7CD     IN R28, 0x3D
0035  B7DE     IN R29, 0x3E
0036  8389     STD Y+1, R24
0037  839A     STD Y+2, R25
127:           	if (page_buffer->adress == 0xff) {
0038  8189     LDD R24, Y+1
0039  819A     LDD R25, Y+2
003A  01FC     MOVW R30, R24
003B  8180     LD R24, Z
003C  3F8F     CPI R24, 0xFF
003D  F411     BRNE 0x40
128:           		return false;
003E  E080     LDI R24, 0x00
003F  C010     RJMP 0x50
129:           	}
130:           	page_buffer->adress = 0x1f;
0040  8189     LDD R24, Y+1
0041  819A     LDD R25, Y+2
0042  E12F     LDI R18, 0x1F
0043  01FC     MOVW R30, R24
0044  8320     ST Z, R18
131:           	page_buffer->crc8 = 0x2f;
0045  8189     LDD R24, Y+1
0046  819A     LDD R25, Y+2
0047  E22F     LDI R18, 0x2F
0048  01FC     MOVW R30, R24
0049  8322     STD Z+2, R18
132:           	page_buffer->dataSize = 64;
004A  8189     LDD R24, Y+1
004B  819A     LDD R25, Y+2
004C  E420     LDI R18, 0x40
004D  01FC     MOVW R30, R24
004E  8321     STD Z+1, R18
133:           	return true;
004F  E081     LDI R24, 0x01
134:           }
0050  900F     POP R0
0051  900F     POP R0
0052  91DF     POP R29
0053  91CF     POP R28
0054  9508     RET
135:           
136:           static void
137:           page_write(update_rec* page_buffer)
138:           {
0055  93CF     PUSH R28
0056  93DF     PUSH R29
0057  D000     RCALL 0x58
0058  B7CD     IN R28, 0x3D
0059  B7DE     IN R29, 0x3E
005A  8389     STD Y+1, R24
005B  839A     STD Y+2, R25
139:           	page_buffer->adress = 0xff;
005C  8189     LDD R24, Y+1
005D  819A     LDD R25, Y+2
005E  EF2F     LDI R18, 0xFF
005F  01FC     MOVW R30, R24
0060  8320     ST Z, R18
140:           	//	uint8_t *app_ptr = (uint8_t *)MAPPED_APPLICATION_START;
141:           	//	while(app_ptr - MAPPED_PROGMEM_START <= (uint8_t *)PROGMEM_END) {
142:           	//		/* Receive and echo data before loading to memory */
143:           	//		uint8_t rx_data = twi_receive();
144:           	//		twi_send(rx_data);
145:           	//
146:           	//		/* Incremental load to page buffer before writing to Flash */
147:           	//		*app_ptr = rx_data;
148:           	//		app_ptr++;
149:           	//		if(!((uint16_t)app_ptr % MAPPED_PROGMEM_PAGE_SIZE)) {
150:           	//			/* Page boundary reached, Commit page to Flash */
151:           	//			_PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
152:           	//			while(NVMCTRL.STATUS & NVMCTRL_FBUSY_bm);
153:           	//
154:           	//			toggle_status_led();
155:           	//		}
156:           	//	}
157:           	//
158:           }
0061  0000     NOP
0062  900F     POP R0
0063  900F     POP R0
0064  91DF     POP R29
0065  91CF     POP R28
0066  9508     RET
